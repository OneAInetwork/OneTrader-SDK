// lib/feature-sdk/index.js
import { NextResponse } from 'next/server';

export class FeatureSDK {
  constructor(config) {
    this.config = {
      id: config.id,
      version: config.version || '1.0.0',
      name: config.name,
      ...config
    };
    this.validators = new Validators();
    this.formatters = new Formatters();
    this.cache = new CacheManager();
  }
  
  // Request validation
  async validateRequest(request) {
    const checks = [
      this.validators.checkRateLimit(request, this.config.id),
      this.validators.checkAPIKey(request),
      this.validators.checkParameters(request, this.config)
    ];
    
    const results = await Promise.all(checks);
    const failed = results.find(r => !r.valid);
    
    return failed || { valid: true };
  }
  
  // Parameter extraction
  getParameters(request) {
    const url = new URL(request.url);
    const params = {};
    
    for (const [key, value] of url.searchParams) {
      params[key] = value;
    }
    
    // Validate against manifest
    if (this.config.api?.parameters) {
      for (const param of this.config.api.parameters) {
        if (param.required && !params[param.name]) {
          throw new Error(`Missing required parameter: ${param.name}`);
        }
        if (param.type && params[param.name]) {
          params[param.name] = this.castParameter(params[param.name], param.type);
        }
      }
    }
    
    return params;
  }
  
  // Type casting for parameters
  castParameter(value, type) {
    switch (type) {
      case 'number':
        return parseFloat(value);
      case 'integer':
        return parseInt(value);
      case 'boolean':
        return value === 'true';
      case 'array':
        return value.split(',');
      default:
        return value;
    }
  }
  
  // Body parsing with validation
  async parseBody(request) {
    try {
      const body = await request.json();
      
      // Validate required fields
      if (this.config.api?.body) {
        for (const field of this.config.api.body) {
          if (field.required && !body[field.name]) {
            throw new Error(`Missing required field: ${field.name}`);
          }
        }
      }
      
      return body;
    } catch (error) {
      if (error instanceof SyntaxError) {
        throw new Error('Invalid JSON in request body');
      }
      throw error;
    }
  }
  
  // Response helpers
  successResponse(data, status = 200) {
    const response = {
      success: true,
      featureId: this.config.id,
      version: this.config.version,
      timestamp: new Date().toISOString(),
      ...data
    };
    
    // Add feature metadata if configured
    if (this.config.includeMetadata) {
      response.metadata = {
        author: this.config.author,
        category: this.config.prompt?.category
      };
    }
    
    return NextResponse.json(response, { status });
  }
  
  errorResponse(message, status = 400, code = null) {
    return NextResponse.json({
      success: false,
      error: message,
      code: code || `${this.config.id}_ERROR`,
      featureId: this.config.id,
      timestamp: new Date().toISOString()
    }, { status });
  }
  
  // Permission checks
  requiresWallet() {
    return this.config.api?.requiresWallet || 
           this.config.permissions?.readBalance || 
           this.config.permissions?.executeTrade;
  }
  
  requiresAuth() {
    return this.config.api?.requiresAuth || false;
  }
  
  hasPermission(permission) {
    return this.config.permissions?.[permission] || false;
  }
  
  // Trade intent formatting
  formatTradeIntent(params) {
    const {
      base,
      quote,
      amount,
      type = 'BUY',
      slippageBps = 300,
      amountIs = type === 'BUY' ? 'QUOTE' : 'BASE'
    } = params;
    
    return {
      type,
      base,
      quote,
      amount: amount.toString(),
      amountIs,
      slippageBps,
      timestamp: new Date().toISOString(),
      featureId: this.config.id,
      rationale: params.rationale || `Generated by ${this.config.name}`
    };
  }
  
  // Batch trade formatting
  formatBatchTrades(trades) {
    return trades.map(trade => this.formatTradeIntent(trade));
  }
  
  // External API helpers with caching
  async fetchWithCache(url, options = {}, ttl = 300) {
    const cacheKey = `${this.config.id}:${url}`;
    
    // Check cache first
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return cached;
    }
    
    // Fetch fresh data
    const response = await fetch(url, {
      ...options,
      headers: {
        'User-Agent': `FeatureSDK/${this.config.version} (${this.config.id})`,
        ...options.headers
      }
    });
    
    if (!response.ok) {
      throw new Error(`External API error: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Cache the result
    await this.cache.set(cacheKey, data, ttl);
    
    return data;
  }
  
  // Solana helpers
  async getTokenPrice(tokenSymbol) {
    const url = `https://api.coingecko.com/api/v3/simple/price?ids=${tokenSymbol}&vs_currencies=usd`;
    const data = await this.fetchWithCache(url, {}, 60);
    return data[tokenSymbol]?.usd || 0;
  }
  
  async getWalletBalance(publicKey, token = 'SOL') {
    // Use the existing balance API
    const response = await fetch(`/api/tx2/ultra/balances/${publicKey}`);
    const balances = await response.json();
    return balances[token] || { amount: '0', uiAmount: 0 };
  }
  
  // Analytics
  async logUsage(action, data = {}) {
    try {
      await fetch('/api/features/analytics', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          featureId: this.config.id,
          action,
          data,
          timestamp: new Date().toISOString()
        })
      });
    } catch (error) {
      console.error('Analytics error:', error);
    }
  }
}

// Validators class
class Validators {
  constructor() {
    this.rateLimits = new Map();
  }
  
  async checkRateLimit(request, featureId) {
    const ip = request.headers.get('x-forwarded-for') || 'unknown';
    const key = `${featureId}:${ip}`;
    const now = Date.now();
    
    const limit = this.rateLimits.get(key) || { count: 0, reset: now + 60000 };
    
    if (now > limit.reset) {
      limit.count = 0;
      limit.reset = now + 60000;
    }
    
    limit.count++;
    this.rateLimits.set(key, limit);
    
    // 60 requests per minute default
    if (limit.count > 60) {
      return { 
        valid: false, 
        error: 'Rate limit exceeded. Try again in a minute.' 
      };
    }
    
    return { valid: true };
  }
  
  async checkAPIKey(request) {
    const apiKey = request.headers.get('x-api-key');
    
    // Only check if feature requires it
    if (request.headers.get('x-requires-api-key') === 'true' && !apiKey) {
      return { 
        valid: false, 
        error: 'API key required' 
      };
    }
    
    return { valid: true };
  }
  
  async checkParameters(request, config) {
    if (!config.api?.parameters) {
      return { valid: true };
    }
    
    const url = new URL(request.url);
    const params = url.searchParams;
    
    for (const param of config.api.parameters) {
      if (param.required && !params.has(param.name)) {
        return {
          valid: false,
          error: `Missing required parameter: ${param.name}`
        };
      }
      
      // Validate format if specified
      if (param.format && params.has(param.name)) {
        const value = params.get(param.name);
        if (!this.validateFormat(value, param.format)) {
          return {
            valid: false,
            error: `Invalid format for parameter ${param.name}: expected ${param.format}`
          };
        }
      }
    }
    
    return { valid: true };
  }
  
  validateFormat(value, format) {
    const formats = {
      email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      url: /^https?:\/\/.+/,
      address: /^[1-9A-HJ-NP-Za-km-z]{32,44}$/,  // Solana address
      number: /^\d+(\.\d+)?$/,
      integer: /^\d+$/
    };
    
    return formats[format] ? formats[format].test(value) : true;
  }
}

// Formatters class
class Formatters {
  currency(amount, decimals = 2) {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals
    }).format(amount);
  }
  
  percentage(value, decimals = 2) {
    return `${value > 0 ? '+' : ''}${value.toFixed(decimals)}%`;
  }
  
  number(value, decimals = 2) {
    if (value === 0) return '0';
    if (value < 0.0001) return '<0.0001';
    if (value < 1) return value.toFixed(4);
    if (value < 1000) return value.toFixed(decimals);
    return value.toLocaleString(undefined, {
      minimumFractionDigits: 0,
      maximumFractionDigits: decimals
    });
  }
  
  token(amount, symbol, decimals = 4) {
    return `${this.number(amount, decimals)} ${symbol}`;
  }
  
  address(address, chars = 8) {
    if (!address) return '';
    return `${address.slice(0, chars)}...${address.slice(-chars)}`;
  }
  
  timeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - new Date(timestamp).getTime()) / 1000);
    
    if (seconds < 60) return `${seconds}s ago`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    return `${Math.floor(seconds / 86400)}d ago`;
  }
}

// Simple in-memory cache manager
class CacheManager {
  constructor() {
    this.cache = new Map();
  }
  
  async get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (item.expires < Date.now()) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  async set(key, data, ttl = 300) {
    this.cache.set(key, {
      data,
      expires: Date.now() + (ttl * 1000)
    });
    
    // Clean expired entries periodically
    if (this.cache.size > 100) {
      this.cleanup();
    }
  }
  
  cleanup() {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (item.expires < now) {
        this.cache.delete(key);
      }
    }
  }
}

// Export everything
export { Validators, Formatters, CacheManager };
export default FeatureSDK;
